



# 面试题一 

##  1. 为什么Java转go

go比java有着更便利的语法，更快的速度，而且目前主流大厂都在向着Go靠拢。



## 2. go的切片可以比较吗？

不能直接使用关系运算符比较，但可以使用如DeepEqual函数进行比较

```go
func main() {
	str1 := []string{"123", "hwt"}
	//str2 := []string{"123", "hwt"}
	str2 := []string{"hwt", "123"}
	ok := reflect.DeepEqual(str1, str2)
	if ok {
		fmt.Println("ok")
	} else {
		fmt.Println("not ok")
	}
}
//为真代表相等，为假代表不等
```



## 3. 切片和数组的区别是什么?

切片的底层是通过数组实现的，也就是说，切片其实是一种抽象的数组

数组：
数组固定长度
数组长度是数组类型的一部分，所以[3]int和[4]int是两种不同的数组类型
数组需要指定大小，不指定也会根据初始化的内容自动推算出大小，不可改变
数组是通过值传递的

切片：
切片可以改变长度
切片是轻量级的数据结构，三个属性，指针，长度，容量
不需要指定大小
切片是地址传递（引用传递）
可以通过数组来初始化，也可以通过内置函数make()来初始化，初始化的时候len=cap，然后进行扩容



## 4. 如何有序遍历map？

（1）使用一个切片来记录键的顺序，之后都按照切片中的顺序进行遍历

```go
func main() {
	myMap := map[string]int{
		"one":   1,
		"three": 3,
		"two":   2,
	}

	// 保存键的顺序
	var keys []string
	for k := range myMap {
		keys = append(keys, k)
	}

	// 按照键的顺序遍历 map
	for _, k := range keys {
		fmt.Printf("%s: %d\n", k, myMap[k])
	}
}
```

(2) 使用有序的三方库

```
import (
    "fmt"
    "github.com/wangjia184/sortedmap"
)

func main() {
    myMap := sortedmap.New()
    myMap.Set("one", 1)
    myMap.Set("three", 3)
    myMap.Set("two", 2)

    // 遍历有序的 map
    for it := myMap.Iterator(); it.Next(); {
        fmt.Printf("%s: %v\n", it.Key(), it.Value())
    }
}
```



## 5. go语言是如何实现继承的

 Go 不支持面向对象的三大特性之一——继承。但是 Go 可以通过组合的思想去实现 “继承”,也就是类型嵌入。

类型嵌入，指的是一个类型的定义里嵌入了其他类型。类型嵌入包含两种，一种是结构体类型嵌入，另一种是接口类型嵌入。

结构体嵌入：直接以结构体类型作为结构体的字段，隐式实现了原结构体中的字段和方法

接口类型嵌入：接口中内嵌其他接口类型，使得新接口拥有原接口中的方法



## 6. go语言是如何实现多态的？

面向对象中的多态是指一个对象可以具有多种不同的形态或表现方式。简单来说，就是同一个类型的对象，在不同的上下文中表现出不同的行为

在Golang中主要是采用了接口来实现多态，先定义一个抽象接口，然后再定义具体的实现类并实现接口中的方法。

当我们需要定义一个通用的方法时，方法的入参可以先接收一个接口类型，之后动态地把该接口指向具体类型，从而执行具体类型的方法。

这样就实现了调用相同的方法名，执行不同的操作，这就是go语言的多态。

```go
// 通知者接口
type Notifier interface {
	// 通知方法，可以由具体的类进行实现
	notify()
}

//具体实现
type WechatNotifier struct {
	Name    string
	Message string
}

func (w *WechatNotifier) notify() {
	fmt.Printf("%v notify %v \n", w.Name, w.Message)
}

type QQNotifier struct {
	Name    string
	Message string
}

func (q *QQNotifier) notify() {
	fmt.Printf("%v notify %v \n", q.Name, q.Message)
}

type EmailNotifier struct {
	Name    string
	Message string
}

func (e *EmailNotifier) notify() {
	fmt.Printf("%v notify %v \n", e.Name, e.Message)
}

//定义发送通知方法，入参为Notifier；等需要调用的时候，需要传入实现了Notifier中的接口的类型
func sendNotify(notifier Notifier) {
	notifier.notify()
}

```

```go
//测试
func main() {
	w := &WechatNotifier{
		Name:    "微信",
		Message: "微信消息",
	}

	q := &QQNotifier{
		Name:    "QQ",
		Message: "QQ消息",
	}

	e := &EmailNotifier{
		Name:    "Email",
		Message: "Email消息",
	}

	// 接受微信类型
	sendNotify(w)
	// 接受QQ类型
	sendNotify(q)
	// 接受Email类型
	sendNotify(e)
}

```





## 7. 携程是什么？

Go 协程是与其他函数同时运行的函数。可以认为 Go 协程是轻量级的线程，由 Go 运行时来管理。

在函数调用前加上 go 关键字，这次调用就会在一个新的 goroutine 中并发执行。当被调用的函数返回时，这个 goroutine 也自动结束。

Go 协程之间通过信道进行通信，简单的说就是多个协程之间通信的管道。信道可以防止多个协程访问共享内存时发生资源争抢的问题。

需要注意的是，如果这个函数有返回值，那么这个返回值会被丢弃，如需要获取，可通过channel实现。



## 8. 携程是运行不需要cpu切换线程吗？

在Go语言中，协程（goroutine）是一个非常轻量级的线程实现。Go语言的运行时系统基于一种高效的M:N线程模型，这意味着多个协程会被映射到少量的操作系统线程上执行，从而减少线程切换的开销。

具体来说，Go的调度器会管理协程的执行。当一个协程遇到I/O操作、休眠或者显式地通过`runtime.Gosched()`释放控制权时，调度器会安排其他协程运行。这种机制使得协程的切换主要在用户态完成，而不需要频繁的CPU上下文切换。

因此，虽然Go的协程在运行时确实需要CPU切换线程，但这种切换是非常高效的，开销也相对较小。这使得Go语言在处理高并发任务时表现得非常出色。



## 9. 除了channel还有其他什么可以实现携程间的通信吗？（上下文）

**（主要）1：共享变量和互斥锁（Mutex）：**

通过共享变量和互斥锁（sync.Mutex）来保护共享数据，确保在同一时间只有一个协程可以访问该数据。

这种方式虽然有效，但需要小心处理以避免死锁和竞态条件。

**2：条件变量（Condition Variable）：**

使用条件变量（sync.Cond）可以让一个协程等待某个条件满足后再继续执行。条件变量通常与互斥锁一起使用，用于更复杂的同步场景。

**3：等待组（WaitGroup）：**

sync.WaitGroup用于等待一组协程完成。主协程可以调用WaitGroup的Wait方法等待所有协程完成任务。

**4：原子操作（Atomic Operations）：**

Go语言提供了一些原子操作（如sync/atomic包中的操作）来对整数和指针进行原子读写，避免使用锁1。这些方法各有优缺点，选择哪种方式取决于具体的应用场景和需求。

## 10. 如果需要启动100个携程，但是程序要求同一时间内最多运行10个，有什么办法

可以使用带缓冲区的`channel`来控制并发数量

1. 创建了一个带缓冲区大小为10的`channel`。
2. 每次启动一个新的协程前，向`channel`发送一个空结构体（`struct{}{}`），如果缓冲区已满，则会阻塞，直到有空间。
3. 协程完成工作后，从`channel`中读取一个值，释放缓冲区。

这种方法确保了同一时间内最多只有10个协程在运行。

```
package main

import (
    "fmt"
    "sync"
    "time"
)

func worker(id int, wg *sync.WaitGroup, ch chan struct{}) {
    defer wg.Done()
    fmt.Printf("Worker %d starting\n", id)
    time.Sleep(time.Second) // 模拟工作
    fmt.Printf("Worker %d done\n", id)
    <-ch // 释放缓冲区
}

func main() {
    var wg sync.WaitGroup
    ch := make(chan struct{}, 10) // 缓冲区大小为10

    for i := 1; i <= 100; i++ {
        wg.Add(1)
        ch <- struct{}{} // 占用缓冲区
        go worker(i, &wg, ch)
    }

    wg.Wait()
}
```



## 11. 单点登录如何实现的



## 12. 用户模块用什么验证的

## 13. 支付宝是怎么调用支付接口的？

## 14. 限流器如何实现的？

## 15. 日志是怎么部署的？

## 16. gee框架中的上下文是如何实现通信的？